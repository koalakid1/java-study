outer join
:조인에 참여하는 두 테이블 중 하나의 테이블에 기준삼아서 모든 항목이 다 출력되고, 그 중 
상대테이블에 있는 것만 표시하는 형식이 필요할 때 사용.

left outer join : 왼쪽 테이블이 기준
right outer join : 오른쪽 테이블이 기준

=============================

subquery보다 join이 대체적으로 속도가 빠르므로
join을 사용하는 것을 권장

그러나 케바케

현대의 db는 query optimizer가 컴파일시 가장 좋은 방법을 스스로 찾아서 실행.

=======================================================
연관관계 서브쿼리
:join과 비슷한 동작

1. 먼저 바깥 쿼리의 테이블에서 한 행을 선택
2. 선택된 항 행을 안쪽쿼리의 테이블에서 조건식에서 사용해서 실행
3. 1~2번이 바깥쪽쿼리 테이블의 마지막 행까지 반복
4. 바깥쪽 쿼리가 완성됨 (order by등이 마지막에 실행)

==============================================
pivot
:로우를 컬럼으로 ( 행을 열으로 )

unpivot
:컬럼을 로우로 ( 열을 행으로 )

=======================

업무 내용을 쭉쓰고
명사로 정리 -entity 후보 찾기
종속적인 명사들은 따로 빼서 열로 생성 -attribute 생성

=============================

개념 데이터 모델링 -> 논리 데잍터 모델링 -> 물리 데이터 모델링
개념적                          <------------>                   구체화
개념설계                      <--------------->               상세설계

이러한 요구사항 분석과 정리를 그래프로 그린 것이 ERD(Entity-Relationship Diagram)라고 함

Entity = object (db) 대상
attribute = property 속성

Entity -> table로 구현
attribute -> column으로 구현
Relation -> 관계
: 두 테이블에 참조하는 컬럼이 존재.
=> PK 와 FK

==============================================================

Entity 후보 찾을 때 참고사항
1. 후보가 될 가능성이 있는 대상 무조건 검토
2. 비슷한 단어라도 분류할 것
3. 의미를 모르는 후보가 있으면 개념부터 먼저 확인
4. 모든 경우에 예외가 있으니 예외에 큰 비중 x
5. 순수한 대상 자체이거나 행위 자체
6. 본질적인지 유도된 것인지 구분

==================================

다 : 다
=> 회원 <-> 보험 
=> 고객 <-> 상품 